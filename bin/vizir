#!/usr/bin/env ruby -w

$:.unshift File.join(File.dirname(__FILE__), "..", "lib")

require 'eventmachine'
require 'growl'
require 'json'
require 'net/ssh/gateway'
require 'optparse'
require 'rest_client'
require 'vizir'

FIRST_ALERT_TIME = 600
ALERT_PERIOD = 60
REFRESH_TIME = 3600
IGNORE_SITES = ['grenoble-exp', 'grenoble-ext', 'grenoble-obs', 'luxembourg', 'portoalegre']

def usage
  puts 'usage: vizir [ -h | --help ] [ -l | --login login_name ] [ -p | --password mygrowlpassword ]'
  exit 1
end

def get(api, uri)
  begin
    return JSON.parse(api[uri + '?structure=simple'].get(:accept => 'application/json'))
  rescue => e
    if e.respond_to?('http_code')
      puts "Error: #{e.http_code}:\n #{e.response.body}"
      return nil
    else
      puts e.inspect
      exit 1
    end
  end
end

def setup_ssh_tunnel
  gateway = Net::SSH::Gateway.new('access.grenoble.grid5000.fr', $login)
  port = gateway.open('api.grenoble.grid5000.fr', 443)
  return gateway, port
end

def apiuri(port)
  return "https://localhost:#{port}/oargridapi"
end

def setup_growl
  $growl = Growl::Notifier.sharedInstance
  $growl.register('Vizir', ['Job ending soon'])
end

def notify_via_growl(jobid, site_name, time, time_unit)
  $growl.notify('Job ending soon', 'OAR job terminating soon', "Job #{jobid} in #{site_name} ending in #{time} #{time_unit}.")
end

def get_remaining_time(time)
  return  (time - Time.now).round
end

$login = nil
$password = nil
opts = OptionParser.new
opts.on('-h', '--help') { usage }
opts.on('-l', '--login STRING', String) { |str| $login = str }
opts.on('-p', '--password STRING', String) { |str| $password = str }
opts.parse(ARGV)

if $login == nil or $password == nil
  usage
end

gateway, port = setup_ssh_tunnel
api = RestClient::Resource.new(apiuri(port))
setup_growl

def learn_new_jobs(api)
  $sites.each do |site|
    site_name = site['site']
    unless IGNORE_SITES.include?(site_name)
      jobs = get(api, "#{site['uri']}/jobs")
      break if jobs == nil
      jobs.each do |job|
        if job['owner'] == $login
          job_details = get(api, "#{job['uri']}")
          break if job_details == nil
          if job_details['jobType'] == 'INTERACTIVE'
            jobid = job_details['Job_Id']

            # If we don't yet know the job, record it in $jobs
            if $jobs[jobid].nil?
              $jobs[jobid] = Vizir::Job.new(jobid, Time.at(Integer(job_details['startTime']) + Integer(job_details['walltime'])), site_name.capitalize)
            end
          end
        end
      end
    end
  end
end

def first_ending_job
  $jobs.sort{|a,b| a[1].end_time <=> b[1].end_time}.first
end

def alert_jobs(api)
  $jobs.each do |jobid, job|
    remaining_sec = get_remaining_time(job.end_time)
    if remaining_sec < FIRST_ALERT_TIME
      # Check if the job still exists before sending a notification
      updatedjob = get(api, "/sites/#{job.site_name.downcase}/jobs/#{job.id}")
      if updatedjob['state'] != 'Running'
        # Job is not running anymore, remove it from the hash
        $jobs.delete(jobid)
        next
      end
      if remaining_sec < 0
        $stderr.puts "Error: negative time"
        next
      end
      remaining_time, remaining_time_unit = Vizir.humanize_time(remaining_sec)
      notify_via_growl(jobid, job.site_name, remaining_time, remaining_time_unit)
    end
  end
end

# Learn the Grid'5000 sites
$jobs = Hash.new
$sites = get(api, '/sites')
exit 1 if $sites == nil

learn_new_jobs(api)
alert_jobs(api)

EventMachine::run {
  EventMachine::PeriodicTimer.new(REFRESH_TIME) { learn_new_jobs(api) }
  EventMachine::PeriodicTimer.new(ALERT_PERIOD) { alert_jobs(api) }
}

gateway.shutdown!
